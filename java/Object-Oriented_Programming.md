# 객체지향 프로그래밍

프로그래밍을 할 때 객체 단위로 나누어서, 객체간의 상호작용을 통해 프로그래밍하는 것을 말한다.
속성(데이터(변수)), 행위(알고리즘(메서드))로 이루어진 블록이라고 보면 된다.

절차적 프로그래밍의 경우 main()안에 하나로 줄줄이 프로그래밍 하는 것이라고 보면 된다. 그렇게 하면 코드를 확인하기 힘들기도 하고, 유지보수에 어려움이 있다. 그래서 나온것이 객체지향프로그래밍이다. 안정적이고 대규모 프로젝트에 적합하며 협업이 쉬운 장점이 있다.

**클래스** **Class :** 객체를 만들기 위한 설계도로 하나의 형틀(templet)이다.

**인스턴스 Instance :** 클래스를 활용하여 만든 객체를 인스턴스라고 한다. 때문에 속성과 행위 즉, 변수와 메서드를 가진다.

### 객체지향 프로그래밍 특징(A PIE)

**추상화 Abstraction** : 소프트웨어 목적에 맞게 필요한 특성만 추출해낸다.

**다형성 Polymorphism** : 하나의 객체를 여러관점에서 볼 수 있다. 인간을 예로 들면 동물에 속하기도 하고 포유류이며 하나의 객체로 볼 수 도 있다. 이렇게 다양한 속성을 가질 수 있다.

**상속 Inheritance** : 클래스의 기능을 그대로 상속받아 사용할 수 있다.

**캡슐화 Encapsulation** : 속성과 행위가 결합되어 캡슐이라 하는 것도 있고, 정보은닉이라는 특징을 나타내기도 한다. 가려진 부분이 존재한다는 것..

**장점 :** 모듈화된 프로그래밍이 가능하고, 재사용성이 높다는 장점이 있다.

### 클래스

관련 있는 변수와 함수를 묶어서 만든 사용자정의 자료형으로 객체를 생성하는 하나의 틀이다. 각 대체들이 어떤 속성과 동작을 가질 지 결정하는 것으로 객체들이 서로 상호작용을 할 수 있게 만들어준다.

**클래스의 구성**

- 속성 - 필드(변수,데이터)
- 동작 - 메소드
- 생성자(Constructor)
- 중첩클래스 : 클래스 내부의 클래스

```java
[접근제한자][활용제한자] clss 클래스명 {

		속성 정의 (필드)
		기능 정의 (메소드)
		생성자

}
//예시
public class Person{
		String name;
		int age;

	public void eat(){       ////메서드는
			System.out.println(name+"이 식사를 합니다.");
	}

	public Person(){         //생성자는 자기자신이 속한 클래스명과 동일해야하며
	}                        //반환형을 지정하지 않는다. (메서드와 차이)
}
============================================================================
//동일한 패키지 내에서는 import하지 않아도 된다.
public class PersonTest {

	public static void main(String[] args) {
		Person p1 = new Person(); //객체의 생성 : new 키워드 + 생성자 호출
		p1.name = "고길동";
		p1.age = 30;
		p1.eat();

		Person p2 = new Person();
		p2.name = "박둘리";
		p2.age = 27;
		p2.eat();
	}

}
```

**객체를 생성하는 방법** : 클래스명 변수명 = new 클래스명();

변수명.필드명

변수명.메서드명

. 은 멤버연산자로 그 객체가 어떤 가지고 있는 성질을 나타낸다.

**패키지**

패키지란 클래스가 모여있는 폴더로 모든 클래스는 특정 패키지에 속해있다.

### 변수

**클래스 변수**

static이 들어가 있으면 해당 클래스로 생성된 모든 인스턴스가 공유한다.

**인스턴스 변수**

클래스 영역에 선언하지만, 각 인스턴스별로 생성되어 각 인스턴스가 고유하게 가진다.

**지역변수**

메서드나 생성자에서 안에서 사용되는 변수를 말한다.

```java
public class Person {
	   static String species = "호모 사피엔스 사피엔스";    //static이 있음. 이 클래스로 생성되는 모든 인스턴스가 공유함.

		String name;   // static이 없음 ->인스턴스 변수
		int age;

		public void eat() {
			String dish ="짜장면";   // 지역변수 (메서드나 생성자 안에 들어있는 경우)
		}

}
```

생성자가 없더라도 만약에 생성자가 없으면 JVM이 알아서 생성자를 추가해준다.

### 메서드

특정한 작업을 수행하는 문장들을 묶어서 이름을 붙인 것이다. 메서드의 이름은 소문자로 시작하는 것이 관례이다. 원하는 작업을 수행하는 함수를 정의하는 것이라고 보면 된다.

static : 클래스 변수에서와 마찬가지로 static을 쓰면 인스턴스를 생성하지 않더라도 class.method로 불러 올 수 있다.

```java
[접근제한자][활용제한자] 반환값 메서드이름([매개변수들]) {
				실행할 내용
}
public int add(int a, int b) {
			return a+b;
		}

```

매개변수는 블록안에서 지역변수처럼 사용된다.

void : 반환값이 없는 경우 사용.

메서드의 경우 블록의 끝을 만나거나 리턴문을 만날 때 종료된다. 반환문이 없는 void에서도 return문을 쓸 수 있다.

**메서드오버로딩 (Overloading)**

이름이 같고 매개변수가 다른 메서드를 여러 개 정의하는 것으로 중복코드를 효율적으로 관리 할 수 있다. 다만 파라미터의 개수 또는 순서(자료형의 순서) 또는 타입이 달라야 한다. 리턴 타입이 다른 것은 의미 X

파라미터 순서가 int a, int b / int b, int a 인경우 오버로딩 불가능 → int a string b / string a int b는 오버로딩이 가능

```java
// 예시1 - 메서드 오버로딩
public int add(int a, int b) {
		return a+b;
	}
public double add(double a, double b) {
		return a+b;
	}
==========================================
		//메서드 실행 시
		Person p1 = new Person();
		int sum = p1.add(4, 5);
		double sum2 = p1.add(34.2, 102.1);
		System.out.println(sum);
		System.out.println(sum2);
```

둘 다 똑같이 add라는 이름으로 메서드를 만들 수 있지만 매개변수(파라미터)는 int a / double a 등 서로 달라야한다.

```java
// 예시2 - 메서드 오버로딩
	public void eat() {
		System.out.println("식사를 합니다.");
	}

	public void eat(String dish) {
		System.out.println(dish +"를 먹습니다.");
	}

	public void eat(String dish, int times) {
		System.out.println(dish+"를 "+times+"번 먹습니다.");
	}
	public void eat(int times, String dish){          //이렇게 파라미터의 순서만 달라도 오버로딩이 가능하다.
		System.out.println(times+"번 "+dish+"를 먹습니다.");
	}
=======================================================
		Person p1 = new Person();
		p1.eat();              // 식사를 합니다.
		p1.eat("탕수육");      // 탕수육를 먹습니다.
		p1.eat("햄버거", 3);   // 햄버거를 3번 먹습니다.
		p1.eat(5, "피자");     // 5번 피자를 먹습니다.
	}
}
```

### Static

<JVM이 인스턴스를 만드는 과정> 클래스명 변수명 = new 클래스명();

static이라는 키워드를 앞에 붙이는 경우 : 인스턴스를 생성하기 이전에 인스턴스를 생성하지 않아도 메모리에 올려놓는 것으로 메서드 클래스 부분에 미리 박아두는 것. = 이후 생성되는 모든 인스턴스가 공용으로 사용할 수 있다.

즉, static이라고 쓰는 경우 클래스영역에 미리 올려두는 것이고 non-static인 경우 인스턴스가 생성되어야 쓰는 인스턴스 변수, 인스턴스 메서드이므로 non-static영역안에서는 static메서드를 가져와 사용할 수 있으나, static영역에서는 non-static메서드를 사용할 수 없다. (non-static메서드는 인스턴스가 생성되어야만 사용이 가능한 부분이기 때문.)

### 생성자

new키워드와 동시에 생성자를 호출하여 객체를 생성한다. 클래스명과 동일해야하고 결과형 리턴값을 갖지 않는다. (void를 사용하지 않아도 된다.)

**생성자 오버로딩** : 멤버필드의 초기화에 주로 사용한다. 메서드와 마찬가지로 매개변수가 다르거나 자료형이 다른 여러개의 생성자가 있을 수 있다.

**기본(디폴트)생성자** : 클래스 내에 생성자가 정의되어 있지 않더라도 JVM이 알아서 생성자를 추가해준다.

**파라미터가 있는 생성자 :** 생성자 호출 시 값을 넘겨줘야하며 이 경우 JVM이 기본 생성자를 추가하지 않는다.

```java
Dog a = new Dog(); -> 정의할 때 매개변수를 지정해 뒀으면 꼭 넣어야 함. 이렇게 사용은 불가
```

**this** : 참조변수로서 객체 자기 자신을 가리킨다. 자신의 멤버(변수,메서드)에 접근이 가능하다. 메서드의 매개변수와 객체가 가진 멤버(필드)와 이름이 동일한 경우 필드임을 식별할 수 있게 해준다.
다만, 객체에 대한 참조이므로 static영역에서는 사용이 불가하다. 생성자내의 첫번째 구문에 위치해야하고 생성자 내에서만 호출이 가능하다. 또 다른 생성자를 호출 할 수 있다.

```java
// 파라미터가 있는 생성자
public class Person {
  static String species = "호모 사피엔스 사피엔스";    //static이 있음. 이 클래스로 생성되는 모든 인스턴스가 공유함.

	String name;   // static이 없음 ->인스턴스 변수
	int age;

  public Person() {      // 생성자 오버로딩으로 여러개 생성이 가능. 또 다른 생성자를 호출한다.
		this("최보라", 31);  // 이경우 아래 Person 생성자를 호출하는 것으로 name에 최보라 age에 31을 넣는다.
	};

	public Person(String name, int age){
		// this 키워드: 인스턴스의 멤버에 접근 위에서 정한 name, age등에 접근한다.
		this.name = name;
		this.age = age;
	}

============================================================================
public static void main(String[] args) {
		Person p1 = new Person("박돌이", 28);
		Person p2 = new Person("양뚜비", 29);
		Person p3 = new Person("오나나", 26);
		Person p4 = new Person();   //Person("최보라",31)로 생성자를 호출한 것과 마찬가지이다.

		System.out.println(p1.name);   // 박돌이
		System.out.println(p2.name);   // 양뚜비
		System.out.println(p3.name);   // 오나나
		System.out.println(p4.name);   // 최보라


	}
}
```
